---
title: 工厂模式
date: 2020-03-22 12:57:25
updated: 2019-03-22 15:57:25
tags: 
- java
- 设计模式

---

##### 简单工厂

封装创建对象的代码，解耦对象实力化的逻辑。

<!--more-->

下面为一个创建披萨的简单工厂：

```java
//抽象披萨
public abstract class Pizza {
    String name;
    String dough;
    String sauce;

    void prepare() {
        System.out.println("Preparing" );
    }

    void bake() {
        System.out.println("bake for 25 minutes at 350");
    }

    void cut() {
        System.out.println("cutting the pizza");
    }

    void box() {
        System.out.println("place pizza in box");
    }

    public String getName() {
        return name;
    }

}
public class SimplePizzaFactory {
    public Pizza createPizza(String type) {
        Pizza pizza = null;
        if ("cheese".equals(type)) {
            pizza = new CheesePizza();
        } else if ("pepperoni".equals(type)) {
            pizza = new PepperoniPizza();
        }
        return pizza;
    }
}
```

##### 工厂方法

定义一个创建对象的接口，由子类决定要实例化的类是哪一个。

下面是一个抽象的披萨商店：

```java
public abstract class PizzaStore {
    public abstract Pizza createPizza(String type);
    public Pizza orderPizza(String type){
        Pizza pizza = createPizza(type);
        pizza.cut();
        pizza.bake();
        pizza.box();
        return pizza;
    }
}
```

通过实现不同的披萨商店，达到不同的城市，有不同特色的披萨。

```java
//纽约特色
public class NYPizzaStore extends PizzaStore {
	public Pizza createPizza(String type){
				Pizza pizza = null;
        if ("cheese".equals(type)) {
            pizza = new NYStyleCheesePizza();
        } else if ("pepperoni".equals(type)) {
            pizza = new NYStylePepperoniPizza();
        }
        return pizza;
	}
}
//芝加哥特色
public class ChicagoPizzaStore extends PizzaStore {
	public Pizza createPizza(String type){
				Pizza pizza = null;
        if ("cheese".equals(type)) {
            pizza = new ChicagoStyleCheesePizza();
        } else if ("pepperoni".equals(type)) {
            pizza = new ChicagoStylePepperoniPizza();
        }
        return pizza;
	}
}
```

##### 抽象工厂

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

其中采用了依赖倒置的原则：要依赖抽象，不要依赖具体类。

下面是一个抽象的原料工厂：

```java
public interface PizzaIngredientFactory {
  String createDough();
  String createSauce();
}
```

不同城市通过实现原料工厂，创建出有本地特色的披萨。

```java
//纽约原料厂
public NYPizzaIngredientFactory extends PizzaIngredientFactory{
  public String createDough(){
    return "NYDough";
  }
  public String createSauce(){
    return "NYSauce";
  }
}
//芝加哥原料厂
public ChicagoPizzaIngredientFactory extends PizzaIngredientFactory{
  public String createDough(){
    return "ChicagoDough";
  }
  public String createSauce(){
    return "ChicagoSauce";
  }
}
//干酪披萨
public class CheesePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	public CheesePizza(PizzaIngredientFactory ingredientFactory){
		this.ingredientFactory = ingredientFactory;
	}
	void prepare() {
		dough = ingredientFactory.createDough();
    sauce = ingredientFactory.createSauce();
	}
}

//纽约特色
public class NYPizzaStore extends PizzaStore {
  PizzaIngredientFactory pizzaIngredientFactory = new NYPizzaIngredientFactory();
	public Pizza createPizza(String type){
				Pizza pizza = null;
        if ("cheese".equals(type)) {
            pizza = new CheesePizza(pizzaIngredientFactory);
        } else if ("pepperoni".equals(type)) {
            pizza = new PepperoniPizza(pizzaIngredientFactory);
        }
        return pizza;
	}
}
//芝加哥特色
public class ChicagoPizzaStore extends PizzaStore {
  PizzaIngredientFactory pizzaIngredientFactory = new ChicagoPizzaIngredientFactory();
	public Pizza createPizza(String type){
				Pizza pizza = null;
        if ("cheese".equals(type)) {
            pizza = new CheesePizza(pizzaIngredientFactory);
        } else if ("pepperoni".equals(type)) {
            pizza = new PepperoniPizza(pizzaIngredientFactory);
        }
        return pizza;
	}
}

public void static main(String[] args){
  PizzaStore store = new ChicagoPizzaStore();
 	Pizza pizza = store.orderPizza("cheese");
}


```

